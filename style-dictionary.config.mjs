import StyleDictionary from 'style-dictionary';

/** Order matching the original lib/theme.ts for readability. */
const categoryOrder = ['colors', 'text', 'spacing', 'radius', 'layout', 'shadow', 'transition', 'nav'];

/**
 * Returns true when a JS identifier must be quoted in object literals
 * (starts with a digit, contains hyphens, etc.).
 */
function needsQuote(key) {
  return !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key);
}

/** Group flat token list by the first path segment. */
function groupTokens(allTokens) {
  const groups = new Map();
  for (const token of allTokens) {
    const [group, key] = token.path;
    if (!groups.has(group)) groups.set(group, []);
    groups.get(group).push({ key, value: token.$value, type: token.$type });
  }
  // Return entries in the canonical order, falling back to insertion order.
  const ordered = [];
  for (const cat of categoryOrder) {
    if (groups.has(cat)) ordered.push([cat, groups.get(cat)]);
  }
  // Append any categories not in the explicit order list.
  for (const [cat, tokens] of groups) {
    if (!categoryOrder.includes(cat)) ordered.push([cat, tokens]);
  }
  return ordered;
}

// ---------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------

const config = {
  source: ['tokens/**/*.json'],
  usesDtcg: true,
  log: { verbosity: 'default' },
  platforms: {
    ts: {
      transforms: ['name/category-kebab'],
      buildPath: 'lib/',
      files: [
        {
          destination: 'theme.generated.ts',
          format: 'typescript/grouped-const',
        },
      ],
    },
    css: {
      transforms: ['name/category-kebab'],
      buildPath: 'lib/',
      files: [
        {
          destination: 'tokens.generated.css',
          format: 'css/custom-properties-grouped',
        },
      ],
    },
  },
  hooks: {
    transforms: {
      /* Include category prefix in name to avoid collision warnings. */
      'name/category-kebab': {
        type: 'name',
        transform: (token) => token.path.join('-'),
      },
    },
    formats: {
      /* ── TypeScript: grouped `export const … = { … } as const;` ── */
      'typescript/grouped-const': async ({ dictionary }) => {
        const groups = groupTokens(dictionary.allTokens);
        let out = '// Auto-generated by Style Dictionary — do not edit manually.\n\n';

        for (const [group, tokens] of groups) {
          out += `export const ${group} = {\n`;
          for (const { key, value } of tokens) {
            const k = needsQuote(key) ? `'${key}'` : key;
            const v = typeof value === 'number' ? String(value) : `'${value}'`;
            out += `  ${k}: ${v},\n`;
          }
          out += '} as const;\n\n';
        }

        return out.trimEnd() + '\n';
      },

      /* ── CSS: `:root { --group-key: value; }` ── */
      'css/custom-properties-grouped': async ({ dictionary }) => {
        const groups = groupTokens(dictionary.allTokens);
        let out =
          '/* Auto-generated by Style Dictionary — do not edit manually. */\n\n:root {\n';

        for (const [group, tokens] of groups) {
          out += `  /* ${group} */\n`;
          for (const { key, value, type } of tokens) {
            const cssValue = type === 'number' ? `${value}px` : value;
            out += `  --${group}-${key}: ${cssValue};\n`;
          }
          out += '\n';
        }

        return out.trimEnd() + '\n}\n';
      },
    },
  },
};

// ---------------------------------------------------------------------------
// Build
// ---------------------------------------------------------------------------

const sd = new StyleDictionary(config);
await sd.buildAllPlatforms();
